" Basic vim configuration
scriptencoding utf-8
set encoding=utf-8
set nocp            " not vi-compatible, probably redundant with .vimrc?
set bs=indent,eol,start     " allow backspace to jump over these items
set ic              " ignore case
syntax on           " Syntax highlighting
filetype plugin indent on
" Disable bell sound with visualbell and disable flashing
set visualbell
set t_vb=
" Setting filetypes
autocmd BufRead,BufNewFile *.babelrc set filetype=json
autocmd BufRead,BufNewFile *.eslintrc set filetype=json
" set path+=**        " improve find
set wildignorecase  " case insensitive file autocomplete
set mouse=a         " enable mouse
let mapleader=','   " Set the leader key

" https://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md
set nomodeline

" Auto install plug if not already installed
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('~/.vim/plugged')

" General pugins
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-obsession'
Plug 'tpope/vim-unimpaired'
Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
Plug 'henrik/vim-indexed-search'

" Colorschemes
Plug 'NLKNguyen/papercolor-theme'

Plug 'w0rp/ale'

" Plug 'jiangmiao/auto-pairs'
" let g:AutoPairsMapSpace = 0
" let g:AutoPairsMultilineClose = 0
" Plug 'alvan/vim-closetag', { 'for': 'html,javascript.jsx,typescript.tsx' }
" let g:closetag_filenames = '*.html,*.js,*.jsx,*.tsx'
" let g:closetag_xhtml_filenames = '*.js,*.jsx,*.tsx'
" let g:closetag_emptyTags_caseSensitive = 1
" pear-tree sometimes fails to smartly close things
" Plug 'tmsvg/pear-tree'
" Using fork for now until https://github.com/tmsvg/pear-tree/pull/32 is
" merged or addressed, for typescript generics
Plug 'bryclee/pear-tree', { 'branch': 'wildcardCloser' }
let g:pear_tree_repeatable_expand = 0
" let g:pear_tree_smart_openers = 1
" let g:pear_tree_smart_closers = 1
" let g:pear_tree_smart_backspace = 1
" let g:pear_tree_timeout = 1000
let g:pear_tree_pairs = {
      \ '(': { 'closer': ')', 'not_in': ['String', 'Comment'] },
      \ '[': { 'closer': ']', 'not_in': ['String', 'Comment'] },
      \ '{': { 'closer': '}', 'not_in': ['String', 'Comment'] },
      \ "'": { 'closer': "'" },
      \ '"': { 'closer': '"' },
      \ '<*>': { 'closer': '</*>',
      \          'not_if': ['br', 'hr', 'img', 'input', 'link', 'meta',
      \                  'area', 'base', 'col', 'command', 'embed',
      \                  'keygen', 'param', 'source', 'track', 'wbr'],
      \          'not_like': '{[^}]*$\|/$',
      \          'until': '[^a-zA-Z0-9-._]',
      \          'not_at': ['[^> ]'],
      \          'not_in': ['String', 'Comment']
      \        },
      \ '<!--': { 'closer': '-->'}
      \ }

" Plug 'vim-airline/vim-airline'
" set noshowmode
set laststatus=2
" let g:airline#extensions#tabline#enabled = 1
" let g:airline#extensions#tabline#tab_min_count = 2
" let g:airline#extensions#tabline#show_buffers = 0
" let g:airline#extensions#tabline#show_splits = 0
" let g:airline#extensions#tabline#formatter = 'unique_tail_improved'
" let g:airline#extensions#tabline#tab_nr_type = 2
" let g:airline#extensions#tabline#show_close_button = 0
" Trimming some sections earlier so more of the file path can be shown
    " airline_section_b (hunks, branch)
    " airline_section_y (fileencoding, fileformat)
" let g:airline#extensions#default#section_truncate_width = {
"     \ 'b': 110,
"     \ 'x': 110,
"     \ 'y': 120
"     \ }
" Abbreviating the vim mode mapping in the bottom left corner
" let g:airline_mode_map = {
"     \ '__' : '-',
"     \ 'c'  : 'C',
"     \ 'i'  : 'I',
"     \ 'ic' : 'I',
"     \ 'ix' : 'I',
"     \ 'n'  : 'N',
"     \ 'ni' : 'N',
"     \ 'no' : 'N',
"     \ 'R'  : 'R',
"     \ 'Rv' : 'R',
"     \ 's'  : 'S',
"     \ 'S'  : 'S',
"     \ '' : 'S',
"     \ 't'  : 'T',
"     \ 'v'  : 'V',
"     \ 'V'  : 'V',
"     \ '' : 'V',
"     \ }
" let g:airline#extensions#obsession#enabled = 1

Plug 'simnalamburt/vim-mundo'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-rhubarb'
Plug 'airblade/vim-gitgutter'
set updatetime=500 " Write swap file to disk quicker, also gives faster diff updates
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'
Plug 'justinmk/vim-dirvish'
Plug 'tpope/vim-vinegar'

" Goyo is nice for text editing. Use :Goyo and :Goyo! to enter goyo mode.
" Plug 'junegunn/goyo.vim'
" let g:goyo_width = 90
" autocmd! User GoyoEnter set linebreak
" autocmd! User GoyoLeave set nolinebreak

" LSP
" Install Coc. Install yarn if not already installed
function! InstallCoc()
  if !executable('yarn')
    !npm install -g yarn
  endif
  call coc#util#install()
endfunction
Plug 'neoclide/coc.nvim', {'branch': 'release', 'do': { -> InstallCoc() }}
let g:coc_global_extensions = ['coc-json', 'coc-html', 'coc-tsserver']

" coc.nvim
" ===================
" Set tab completion
inoremap <silent><expr> <TAB>
  \ pumvisible() ? "\<C-y>" : "\<TAB>"

" Go to definition
nmap <silent> <leader>d <Plug>(coc-definition)
nmap <silent> <leader>D <Plug>(coc-type-definition)
nmap <silent> <C-W><leader>d :call CocActionAsync('jumpDefinition', 'tabe')<CR>
nmap <silent> <leader>i <Plug>(coc-implementation)
nmap <silent> <leader>r <Plug>(coc-references)
nmap <silent> <leader>R <Plug>(coc-rename)
nmap <silent> gh :call CocAction('doHover')<CR>
inoremap <silent><expr> <c-space> coc#refresh()
nmap <silent> [D <Plug>(coc-diagnostic-prev)
nmap <silent> ]D <Plug>(coc-diagnostic-next)

" Language specific
Plug 'pangloss/vim-javascript'
Plug 'mxw/vim-jsx'
Plug 'groenewege/vim-less'
Plug 'ap/vim-css-color'
Plug 'styled-components/vim-styled-components', { 'branch': 'main' }
" Trying using ALEFix instead
" Plug 'prettier/vim-prettier', { 'do': 'npm install -g prettier' }
Plug 'leafgarland/typescript-vim'
" vim-jsx-typescript has some indentation bugs, so sticking with vim-tsx even
" though defunct
" Plug 'peitalin/vim-jsx-typescript'
Plug 'tasn/vim-tsx'
Plug 'motus/pig.vim'
Plug 'jparise/vim-graphql'
Plug 'digitaltoad/vim-pug'
" Plug 'plasticboy/vim-markdown'
" Plug 'prurigro/vim-markdown-concealed'

call plug#end()

set t_Co=16
set background=light
colorscheme custom

" Move file directories away from local directory
" The trailing // is to use absolute path
set backupdir=~/.vim/.backup//

" Read if file has changed from outside vim
set autoread

" Force markdown highlighting for *.md
" augroup markdown
"   autocmd!
"   autocmd BufNewFile,BufReadPost *.md set filetype=markdown
" augroup END

" For checking syntax highlight of cursor
function! SynGroup()
    let l:s = synID(line('.'), col('.'), 1)
    echo synIDattr(l:s, 'name') . ' -> ' . synIDattr(synIDtrans(l:s), 'name')
endfun

function! TrimStr(str)
  return substitute(a:str, '^\s*\(.\{-}\)\s*$', '\1', '')
endfunction

" Trim trailing whitespace on write.
function! TrimWhiteSpace()
    " Save the last searched
    let _s = @/
    " Save the current cursor position
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    let @/ = _s
    call cursor(l, c)
endfunction
" Autotrim on write...
nnoremap <leader>w :call TrimWhiteSpace()<CR>:w<CR>

" Trailing dots showing whitespace
set list
set listchars=tab:\|\ ,trail:Â·

" Function for toggling a property
" Usage: NMapToggle <keybinding> <string property name>
function! NMapToggle(key, opt)
    " Create chained command string, toggle property and get value of property
    let cmd = ':set '.a:opt.'! \| set '.a:opt."?\<CR>"
    " nnoremap with new cmd
    exec 'nnoremap '.a:key.' '.cmd
endfunction
" Apply variable number of args to NMapToggle?
command! -nargs=+ NMapToggle call NMapToggle(<f-args>)

" Search
set incsearch
set hlsearch
nnoremap <silent> <Leader><Leader> :noh<CR><Esc>
" Use ag for search
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor\ --follow
endif
" Populate current word in search
nnoremap <leader>/ :grep '\b<C-R>=substitute(expand("<cword>"), '#', '\\#', 'g')<CR>\b'<space>

" Autocomplete
set wildmenu    " display autocomplete options in command menu
set complete=.,b,u,] " Autocomplete sources
set wildmode=longest,list:longest " Set autocomplete default replacement behavior
set completeopt=menu " How menu shows

" Bind j and k to move by visual line if text is there
nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k

" Buffers
nnoremap <leader>bd :b# <BAR> bd #<CR> " In case you want to leave the window open
set hidden
nnoremap <silent> <leader>o :call BackBuffer()<CR>
nnoremap <silent> <leader>i :call ForwardBuffer()<CR>

" Navigate via command provided until buffer changes or there are no more
" navigation changes. Mostly for the buffer changes though
function! BackBuffer()
  call UntilBufferChange("\<c-o>")
endfunction
function! ForwardBuffer()
  call UntilBufferChange("1\<c-i>")
endfunction
function! UntilBufferChange(cmd)
  let startName = bufname('%')
  let beforePos = getcurpos()[1:2]
  while 1
    exe "normal! ".a:cmd
    let nowName = bufname('%')
    let nowPos = getcurpos()[1:2]
    if nowName != startName || beforePos == nowPos
      break
    endif
    let beforePos = nowPos
  endwhile
endfunction

" Using splits
set splitbelow
set splitright

" split line
nnoremap K i<CR><Esc>l:call TrimWhiteSpace()<CR>

" " swapping lines
" nnoremap <C-j> :m .+1<CR>
" nnoremap <C-k> :m .-2<CR>
" inoremap <C-j> <Esc>:m .+1<CR>
" inoremap <C-k> <Esc>:m .-2<CR>
" vnoremap <C-j> :m '>+1<CR>gv
" vnoremap <C-k> :m '<-2<CR>gv

" Folding
set foldmethod=indent
set foldlevel=99

" Center cursor
set scrolloff=3

" line columns and ruler
set number
set numberwidth=4
set ruler
set signcolumn=yes

" indentation settings
set autoindent
set tabstop=2
set shiftwidth=2
set expandtab " tab to spaces

" vimdiff - https://vimways.org/2018/the-power-of-diff/
set diffopt+=algorithm:patience

" Populate edit command relative to the current file
map <leader>e :e <C-R>=expand("%:p:h") . "/" <CR>

" webpack watching
set backupcopy=yes

" Allow loading of js files from paths described in json files... most common
" use case
autocmd Filetype json set suffixesadd+=.js

" Plugin config
" =============

" fzf.vim
autocmd! filetype fzf
autocmd  filetype fzf set laststatus=0
  \| autocmd BufLeave <buffer> set laststatus=2
map <C-T> :FZF<CR>
map <C-P> :Buffers<CR>

command! -bang -nargs=* AllFiles call fzf#run(fzf#wrap({ 'source': "find -L * -path '*/\.*' -prune -o -type f -print -o -type l -print 2> /dev/null" }))

" ale
let g:ale_linters = {
      \ 'javascript': ['eslint', 'flow'],
      \ 'javascript.jsx': ['eslint', 'flow'],
      \ 'css': ['eslint'],
      \ 'typescript': ['tslint', 'tsserver'],
      \ 'typescript.tsx': ['tslint', 'tsserver']
      \ }
let g:ale_fixers = {
      \ '*': ['remove_trailing_lines', 'trim_whitespace'],
      \ 'javascript': ['prettier', 'eslint'],
      \ 'javascript.jsx': ['prettier', 'eslint'],
      \ 'typescript': ['prettier', 'tslint'],
      \ 'typescript.tsx': ['prettier', 'tslint'],
      \ 'css': ['prettier'],
      \ 'markdown': ['prettier'],
      \ 'graphql': ['prettier']
      \ }
nmap <silent> <leader>F <Plug>(ale_fix)
nnoremap <silent> [d :ALEPreviousWrap<CR>
nnoremap <silent> ]d :ALENextWrap<CR>

" vim-dirvish
let g:dirvish_mode = ':sort ,^.*[\/],'
augroup dirvish_config
  autocmd!
  " autocmd filetype dirvish silent! unmap <buffer> /
  " autocmd filetype dirvish silent! unmap <buffer> ?
  " autocmd filetype dirvish silent! unmap <buffer> p
  autocmd filetype dirvish silent! unmap <buffer> <c-p>
  autocmd filetype dirvish setlocal nonumber
augroup END

" mundo.vim
" =========
if has("persistent_undo")
    set undofile
    set undodir=~/.vim/.undo//
endif
nnoremap <leader>u :MundoToggle<CR>

" vim-flow
" ========
let g:flow#autoclose = 1
let g:flow#omnifunc = 0
let g:flow#enable = 0

" Prettier
" ========
" nnoremap <leader>P :PrettierAsync<CR>:w<CR>
" let external_prettier = TrimStr(system('which prettier'))
" if !empty(external_prettier)
"   let g:prettier#exec_cmd_path = external_prettier
" endif
" let g:prettier#config#config_precedence = 'prefer-file'
" let g:prettier#config#single_quote = 'true'
" let g:prettier#config#bracket_spacing = 'true'

" vim-javascript
" ==============
let g:javascript_plugin_jsdoc = 1
let g:javascript_plugin_flow = 1

" After we're done with all the common config, check if there's a system local
" config to source
if filereadable(expand('~/.vimrc_local'))
  source ~/.vimrc_local
endif

function! CheckSessionExists()
  if !argc() && filereadable('Session.vim')
    echo 'Existing session exists: Session.vim, it can be loaded with :source Session.vim'
  endif
endfunction

au VimEnter * call CheckSessionExists()
